;;; maze.el --- Maze is Life!
;;-----------------------------------------------------------------------------
;; Written by Eli Barzilay: Maze is Life!   (eli@barzilay.org)

(defvar maze-x-pos  nil)
(defvar maze-y-pos  nil)
(defvar maze-size-x nil)
(defvar maze-size-y nil)
(defvar maze-buffer nil)

(defun maze (size-x &optional size-y)
  "Start a maze, with an optional square of SIZE-X or SIZE-X by SIZE-Y."
  (interactive "P")
  (setq maze-buffer (get-buffer-create "*** Eli Barzilay: Maze is Life! ***"))
  (switch-to-buffer maze-buffer)
  (buffer-disable-undo (current-buffer))
  (read-only-mode 0)
  (delete-region (point-min) (point-max))
  (delete-other-windows)
  (unless size-x
    (setq size-x (1- (/ (window-width) 2))
          size-y (1- (/ (window-height) 2))))
  (unless size-y (setq size-y size-x))
  (setq maze-size-x size-x)
  (setq maze-size-y size-y)
  (message "Making Maze...")
  (maze-draw-screen)
  (maze-draw-maze)
  (switch-to-buffer maze-buffer)
  (read-only-mode 1)
  (while (input-pending-p) (read-event))
  (overwrite-mode 1)
  (maze-mode)
  (goto-char (maze-point (1- maze-size-x) (1- maze-size-y)))
  (maze-plot-char ?X)
  (read-only-mode 0)
  (set-regexp-face "[+-|]+" '*/green)
  (set-regexp-face "X" '*/red)
  (read-only-mode 1)
  (setq maze-x-pos 0 maze-y-pos 0)
  (goto-char (maze-point maze-x-pos maze-y-pos))
  (maze-plot-char ?O)
  (message "Begin..."))

(defvar maze-mode-map nil)

(unless maze-mode-map
  (define-keys (setq maze-mode-map (make-sparse-keymap))
    '("r"     maze)            '("q" maze-quit)
    '("h"     maze-move-left)  '("l" maze-move-right)
    '("j"     maze-move-down)  '("k" maze-move-up)
    '("\C-n"  maze-move-down)  '("\C-p"  maze-move-up)
    '("\C-f"  maze-move-right) '("\C-b"  maze-move-left)
    '([up]    maze-move-up)    '([down]  maze-move-down)
    '([left]  maze-move-left)  '([right] maze-move-right)))

(defun maze-mode ()
  "The maze mode."
  (interactive)
  (setq major-mode 'maze-mode mode-name "Maze")
  (use-local-map maze-mode-map))

(defun maze-move (dir)
  (goto-char (maze-point maze-x-pos maze-y-pos))
  (maze-plot-char ?.)
  (goto-char (+ (point) (cond ((eq dir 'up)    (- 0 (* maze-size-x 2) 2))
                              ((eq dir 'down)  (+ (* maze-size-x 2) 2))
                              ((eq dir 'left)  -1)
                              ((eq dir 'right) 1))))
  (when (memq (char-after (point)) '(?  ?.))
    (maze-plot-char ?.)
    (cond ((eq dir 'up)    (setq maze-y-pos (1- maze-y-pos)))
          ((eq dir 'down)  (setq maze-y-pos (1+ maze-y-pos)))
          ((eq dir 'left)  (setq maze-x-pos (1- maze-x-pos)))
          ((eq dir 'right) (setq maze-x-pos (1+ maze-x-pos)))))
  (goto-char (maze-point maze-x-pos maze-y-pos))
  (maze-plot-char ?O) (sit-for 0)
  (maze-check-win))

(defun maze-move-up    () (interactive) (maze-move 'up))
(defun maze-move-down  () (interactive) (maze-move 'down))
(defun maze-move-left  () (interactive) (maze-move 'left))
(defun maze-move-right () (interactive) (maze-move 'right))

(defun maze-check-win ()
  "Check if user won."
  (when (and (= maze-x-pos (1- maze-size-x)) (= maze-y-pos (1- maze-size-y)))
    (message "**********>>> You win !!! <<<**********")
    (beep) (sit-for 3) (eli-logo)
    (kill-buffer maze-buffer)))

(defun maze-quit ()
  "Get out."
  (interactive)
  (message "... Chicken!") (beep) (sit-for 3)
  (kill-buffer maze-buffer))

(defun maze-draw-screen ()
  "Draw the maze screen."
  (let (x y line1 line2)
    (switch-to-buffer maze-buffer)
    (setq x maze-size-x)
    (while (> x 0) (insert "+-") (setq x (1- x)))
    (insert "+\n")
    (setq line1 (buffer-substring (point-min) (point-max)))
    (setq x maze-size-x)
    (save-excursion (while (> x 0) (insert "|~") (setq x (1- x)))
                    (insert "|\n"))
    (setq line2 (buffer-substring (point) (point-max)))
    (goto-char (point-max)) (insert line1)
    (setq y maze-size-y)
    (while (> y 1) (insert line2 line1) (setq y (1- y)))
    (goto-char (point-min))))

(defun maze-draw-maze ()
  "Draw a maze."
  (let ((x (/ maze-size-x 2)) (y (/ maze-size-y 2))
        newx newy places dir dirs none)
    (switch-to-buffer maze-buffer)
    (goto-char (maze-point x y))
    (maze-plot-char ?#)
    (setq places (list (cons x y)))
    (while places
      (setq dirs (list '(0 . -1) '(-1 . 0) '(0 . 1) '(1 . 0)))
      (setq none t)
      (while (and dirs none)
        (setq dir (elt dirs (random (length dirs))))
        (setq dirs (delete dir dirs))
        (setq newx (+ x (car dir)) newy (+ y (cdr dir)))
        (setq none (not (equal (char-after (maze-point newx newy)) ?~))))
      (if none
        (progn (maze-plot-char ? ) (sit-for 0)
               (setq places (cdr places))
               (when places (setq x (car (car places)) y (cdr (car places))))
          (goto-char (maze-point x y)))
        (let ((p (cond ((> newx x) (1+ (point)))
                       ((> newy y) (+ (point) (* maze-size-x 2) 2))
                       ((< newx x) (1- (point)))
                       ((< newy y) (- (point) (* maze-size-x 2) 2)))))
          (when p (goto-char p) (maze-plot-char ? ))
          (setq x newx y newy)
          (setq places (cons (cons x y) places))
          (goto-char (maze-point x y))
          (maze-plot-char ?#) (sit-for 0))))
    (goto-char (maze-point x y))
    (maze-plot-char ? )))

(defun maze-plot-char (c)
  "Put one char C on the screen."
  (let ((inhibit-read-only t) (inhibit-point-motion-hooks t))
    (insert-and-inherit c)
    (when (memq c '(?. ?O))
      (set-region-face (1- (point)) (point) 'yellow/red4))
    (delete-char 1)
    (goto-char (1- (point)))))

(defun maze-point (x y)
  "Calculate the location of the X, Y point."
  (+ (* (* (1+ maze-size-x) 2) (1+ (* y 2))) (* x 2) 2))

(provide 'maze)

;;; maze.el ends here
